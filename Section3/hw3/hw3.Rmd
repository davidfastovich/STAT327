Name: David Fastovich
Email: fastovich@wisc.edu

Loading required packages and reading data to be processed later
```{r}
require("png")
require("parallel")

vg <- readPNG("Van_Gogh.png")

red.vg <- vg[,,1]
green.vg <- vg[,,2]
blue.vg <- vg[,,3]
```

Filtering function
```{r}
par.chan.filtering <- function(x, k, dim.x) {
  pad.X <- matrix(0, (dim.x[1]+2*k), (dim.x[2]+2*k))
  pad.X[(k+1):(dim.x[1]+k), (k+1):(dim.x[2]+k)] <- x
  filtered.mat <- matrix(0, dim(pad.X)[1], dim(pad.X)[2])
  for(row in (k+1):(dim.x[1]+k)) {
    for(col in (k+1):(dim.x[2]+k)) {
      filtered.mat[row, col] <- mean(pad.X[(row-k):(row+k),(col-k):(col+k)])
    }
  }
  unpadded.mat <- filtered.mat[seq_len(dim.x[1]) + k, seq_len(dim.x[2]) + k]
  print("I keep on looping 1")
  return(unpadded.mat)
}
```

Have to make one function that can be applied in parallel
```{r}
filter.image <- function(x, k, dim.x) {
  filtered.array <- array(data = c(numeric(), numeric(), numeric()), dim = c(dim.x[1],dim.x[2],dim.x[3]))
  for (i in 1:3) {
    filtered.array[,,i] <- par.chan.filtering(vg[,,i][1], k = k, dim.x = dim(vg[,,i]))
  }
  return(filtered.array)
}
  
```

Implementing function on Madison.png using 3 cores
```{r}
n.cores <- detectCores()
cluster <- makePSOCKcluster(names=n.cores)
clusterEvalQ(cl = cluster, expr = par.chan.filtering)
red.filtered <-  parLapply(cl = cluster, red.vg[1], fun = par.chan.filtering, k = 5, dim.x = dim(red.vg))
green.filtered <-  parLapply(cl = cluster, x = green.vg[1], fun = par.chan.filtering, k = 5, dim.x = dim(green.vg))
system.time(blue.filtered <-  parLapply(cl = cluster, blue.vg[1], fun = par.chan.filtering, k = 5, dim.x = dim(blue.vg)))
system.time(filtered.array <- parLapply(cl = cluster, vg[1], fun = filter.image, k = 1, dim.x = dim(vg)))
```